from flask import Flask, jsonify, request
from random import randrange
import requests
import subprocess
import json
import time

# Create a Flask app 
app = Flask(__name__)

# A simple in-memory store for products (could be replaced with a database in a real app)
products_db = []
proof_store = {}  

@app.route('/')
def home():
    return "Welcome to the Certifier API!"

@app.route('/compute', methods=['POST'])
def compute():
    # Check if the product exists in our "database"
    # product = products_db.get(product_id)
    # product_data = request.json
    
    # product = Product(
    #     id=product_data['id'],
    #     name=product_data['name'],
    #     volume=product_data['volume'],
    #     certified=product_data['certified'],
    #     sender=product_data.get('sender')
    # )

    # if not product:
    #     return jsonify({"error": "Product not found!"}), 404

    # # Certify the product
    # product.certified = True

    # products_db.append(product)

    # send_to_distribute(product)

    # return jsonify({
    #     "message": "Product certified successfully",
    #     "product": product.to_dict()
    # })
    data = request.get_json()
    if not data:
        return jsonify({"error": "No product data provided"}), 400

    try:
        result = subprocess.run(
            ["../zkp/target/release/host"],  # neues Binary
            input=json.dumps(data),
            capture_output=True,
            text=True,
            check=True
        )
        output = json.loads(result.stdout)
    except subprocess.CalledProcessError as e:
        return jsonify({"error": "Rust certifier_host failed", "details": e.stderr}), 500
    except json.JSONDecodeError:
        return jsonify({"error": "Invalid JSON from Rust host", "raw": result.stdout}), 500

    product = output.get("product", {})
    proof = output.get("proof", "")
    product_id = product.get("id")

    products_db.append({"product": product})
    proof_store[product_id] = proof

    # sofort an Distributor schicken
    product_obj = Product(
    id=product["id"],
    name=product["name"],
    volume=product["volume"],
    certified=product["certified"],
    sender=product["sender"]
    )

    send_to_distribute(product_obj, proof)

    return jsonify({
        "product": product
    })

@app.route('/proveRetrieval/<int:product_id>', methods=['GET'])
def proofRetrieval(product_id):
    # Simulate creating a product
    # return "TODO /proofRetrieval"
    proof = proof_store.get(product_id)
    if not proof:
        return jsonify({"error": "Proof not found"}), 404
    return jsonify({"product_id": product_id, "proof": proof})

@app.route('/info', methods=['GET'])
def info():
    # Simulate creating a product
    return "Workflow Position: 2<br>This TCU functions as a certifier, recieving products generated by the manufacturer, certifying them and forwarding them to the distributor."

@app.route('/display', methods=['GET'])
def display():

    # Return the list as JSON
    return jsonify(products_db)


def send_to_distribute(product, proof):
    """
    Send a certification request to the Flask API.
    """
    url = "http://127.0.0.1:5004/compute"
    payload = {
        "product": product.to_dict(),     # <-- NEW
        "proof": proof                    # <-- NEW
    }
    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            data = response.json()
            print(f"Sending to Distributor Successful: {data['message']}")
            print(f"Send Product Data: {data['product']}")

        else:
            print(f"Failed to certify product: {response.status_code}")
    except requests.RequestException as e:
        print("Error connecting to certifier:", e)

class Product:
    def __init__(self, id, name, volume, certified, sender):
        self.id = id
        self.name = name  
        self.volume = volume
        self.certified = certified
        self.sender = sender  # initially set, immutable for manufacturer
    
    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "volume": self.volume,
            "certified": self.certified,
            "sender": self.sender
        }

    # @property
    # def sender(self):
    #     return self._sender
    

    def __repr__(self):
        return (f"Product(name='{self.name}', id={self.id}, volume={self.volume}, certified={self.certified}, sender='{self.sender}')")

# Factory function
def generate_product(name, volume):
    product = Product(name, volume)
    print(product)
    return product


if __name__ == '__main__':
    # Run the app on the local development server
    app.run(debug=True, port=5002)